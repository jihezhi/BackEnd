# 深入理解closure（閉包)

https://go.dev/tour/moretypes/25

小夥伴們在進行到這裡時，會遇到這個Function closures的章節。對於熟悉程式設計的小夥伴，可能知道中文叫做“閉包”，而“閉包”對程式設計初學者而言一直是個神秘的領域。那麼，到底什麼是閉包呢？

## 閉包為什麼存在？

我們認為，閉包是語言設計中出現的一種副產品，其本身並沒有什麼特殊的意義。

### 函式是一等公民

`pos, neg := adder(), adder()`

閉包之所以產生，是由於Go語言“函式是一等公民”的性質，也就是說，在Go語言中，函式本身是一個普通的value，可以賦值給變數，可以作為引數傳遞給函式，可以完成一切其他普通value可以完成的事情。

這個性質，叫做“Functions as first-class citizens"（函式是一等公民）。具有這一特性的程式語言，函式和普通value之間並沒有任何區別。

那麼，既然函式可以作為變數傳給函式，這裡就出現了衍生效應：”Higher-order functions“（高階函式）。

### 高階函式

```
func adder() func(int) int {
	sum := 0
	return func(x int) int {
		sum += x
		return sum
	}
}
```

一個普通的函式，傳入一些普通的值，然後返回一些普通的值。然而當一個函式可以傳入其他函式，或者返回一個函式，或者既傳入一個函式也返回一個函式，這個可以接收函式/返回函式的函式就叫做”高階函式“。

相信小夥伴們一經發現，這是一個衍生概念，是”函式是一等公民“規則下的必然結果，其本身並沒有什麼特殊之處。

### 閉包

當一個函式返回一個函式，而被返回的函式如果使用了原函式中的變數，這就構成了一個閉包。在上面的程式碼示例中，被adder函式返回的函式使用了adder函式中的變數sum，那麼被返回的這個函式每被執行一次，adder函式中的sum就會被加一。

透過這種方式被返回的函式，可以視作一個自帶狀態的函式，或者被貼上了資料的函式。這個函式每被執行一次，自帶的內部狀態（準確地說是返回這個函式的函式中的變數）都會發生變化，從而返回不同的值。

可以說，閉包是由於程式語言遵循了”函式是一等公民“規則下的必然結果，其本身並沒有太大意義，我們可以透過邏輯推理來掌握閉包的性質。而在實際應用上也缺乏價值，一般而言明確地使用狀態（而不是貼到某一個函式上）總是一個好主意。
